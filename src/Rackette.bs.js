// Generated by ReScript, PLEASE EDIT WITH CARE
'use strict';

var List = require("bs-platform/lib/js/list.js");
var Curry = require("bs-platform/lib/js/curry.js");
var Caml_obj = require("bs-platform/lib/js/caml_obj.js");
var Caml_int32 = require("bs-platform/lib/js/caml_int32.js");
var Pervasives = require("bs-platform/lib/js/pervasives.js");
var Read$RacketteErrorless = require("./Read.bs.js");
var CS17SetupRackette$RacketteErrorless = require("./CS17SetupRackette.bs.js");

function plus(addends) {
  if (!addends) {
    return Pervasives.failwith("Must have two numbers to add");
  }
  var a = addends.hd;
  if (a.TAG !== /* NumV */0) {
    return Pervasives.failwith("Must have two numbers to add");
  }
  var match = addends.tl;
  if (!match) {
    return Pervasives.failwith("Must have two numbers to add");
  }
  var b = match.hd;
  if (b.TAG === /* NumV */0 && !match.tl) {
    return {
            TAG: /* NumV */0,
            _0: a._0 + b._0 | 0
          };
  } else {
    return Pervasives.failwith("Must have two numbers to add");
  }
}

function minus(subtrahends) {
  if (!subtrahends) {
    return Pervasives.failwith("Must have two numbers to subtract");
  }
  var a = subtrahends.hd;
  if (a.TAG !== /* NumV */0) {
    return Pervasives.failwith("Must have two numbers to subtract");
  }
  var match = subtrahends.tl;
  if (!match) {
    return Pervasives.failwith("Must have two numbers to subtract");
  }
  var b = match.hd;
  if (b.TAG === /* NumV */0 && !match.tl) {
    return {
            TAG: /* NumV */0,
            _0: a._0 - b._0 | 0
          };
  } else {
    return Pervasives.failwith("Must have two numbers to subtract");
  }
}

function times(multipliers) {
  if (!multipliers) {
    return Pervasives.failwith("Must have two numbers to multiply");
  }
  var a = multipliers.hd;
  if (a.TAG !== /* NumV */0) {
    return Pervasives.failwith("Must have two numbers to multiply");
  }
  var match = multipliers.tl;
  if (!match) {
    return Pervasives.failwith("Must have two numbers to multiply");
  }
  var b = match.hd;
  if (b.TAG === /* NumV */0 && !match.tl) {
    return {
            TAG: /* NumV */0,
            _0: Math.imul(a._0, b._0)
          };
  } else {
    return Pervasives.failwith("Must have two numbers to multiply");
  }
}

function divide(dividends) {
  if (!dividends) {
    return Pervasives.failwith("Must have two numbers to divide");
  }
  var a = dividends.hd;
  if (a.TAG !== /* NumV */0) {
    return Pervasives.failwith("Must have two numbers to divide");
  }
  var match = dividends.tl;
  if (!match) {
    return Pervasives.failwith("Must have two numbers to divide");
  }
  var b = match.hd;
  if (b.TAG === /* NumV */0 && !match.tl) {
    return {
            TAG: /* NumV */0,
            _0: Caml_int32.div(a._0, b._0)
          };
  } else {
    return Pervasives.failwith("Must have two numbers to divide");
  }
}

function remainder(dividends) {
  if (!dividends) {
    return Pervasives.failwith("Must have two numbers to find remainder");
  }
  var a = dividends.hd;
  if (a.TAG !== /* NumV */0) {
    return Pervasives.failwith("Must have two numbers to find remainder");
  }
  var match = dividends.tl;
  if (!match) {
    return Pervasives.failwith("Must have two numbers to find remainder");
  }
  var b = match.hd;
  if (b.TAG !== /* NumV */0) {
    return Pervasives.failwith("Must have two numbers to find remainder");
  }
  if (match.tl) {
    return Pervasives.failwith("Must have two numbers to find remainder");
  }
  var b$1 = b._0;
  var a$1 = a._0;
  return {
          TAG: /* NumV */0,
          _0: a$1 - Math.imul(b$1, Caml_int32.div(a$1, b$1)) | 0
        };
}

function lessThan(nums) {
  if (!nums) {
    return Pervasives.failwith("must have two numbers to use <");
  }
  var a = nums.hd;
  if (a.TAG !== /* NumV */0) {
    return Pervasives.failwith("must have two numbers to use <");
  }
  var match = nums.tl;
  if (!match) {
    return Pervasives.failwith("must have two numbers to use <");
  }
  var b = match.hd;
  if (b.TAG === /* NumV */0 && !match.tl) {
    if (a._0 < b._0) {
      return {
              TAG: /* BoolV */1,
              _0: true
            };
    } else {
      return {
              TAG: /* BoolV */1,
              _0: false
            };
    }
  } else {
    return Pervasives.failwith("must have two numbers to use <");
  }
}

function greaterThan(nums) {
  if (!nums) {
    return Pervasives.failwith("must have two numbers to use >");
  }
  var a = nums.hd;
  if (a.TAG !== /* NumV */0) {
    return Pervasives.failwith("must have two numbers to use >");
  }
  var match = nums.tl;
  if (!match) {
    return Pervasives.failwith("must have two numbers to use >");
  }
  var b = match.hd;
  if (b.TAG === /* NumV */0 && !match.tl) {
    if (a._0 > b._0) {
      return {
              TAG: /* BoolV */1,
              _0: true
            };
    } else {
      return {
              TAG: /* BoolV */1,
              _0: false
            };
    }
  } else {
    return Pervasives.failwith("must have two numbers to use >");
  }
}

function lessThanEqualTo(nums) {
  if (!nums) {
    return Pervasives.failwith("must have two numbers to use <=");
  }
  var a = nums.hd;
  if (a.TAG !== /* NumV */0) {
    return Pervasives.failwith("must have two numbers to use <=");
  }
  var match = nums.tl;
  if (!match) {
    return Pervasives.failwith("must have two numbers to use <=");
  }
  var b = match.hd;
  if (b.TAG === /* NumV */0 && !match.tl) {
    if (a._0 <= b._0) {
      return {
              TAG: /* BoolV */1,
              _0: true
            };
    } else {
      return {
              TAG: /* BoolV */1,
              _0: false
            };
    }
  } else {
    return Pervasives.failwith("must have two numbers to use <=");
  }
}

function greaterThanEqualTo(nums) {
  if (!nums) {
    return Pervasives.failwith("must have two numbers to use >=");
  }
  var a = nums.hd;
  if (a.TAG !== /* NumV */0) {
    return Pervasives.failwith("must have two numbers to use >=");
  }
  var match = nums.tl;
  if (!match) {
    return Pervasives.failwith("must have two numbers to use >=");
  }
  var b = match.hd;
  if (b.TAG === /* NumV */0 && !match.tl) {
    if (a._0 >= b._0) {
      return {
              TAG: /* BoolV */1,
              _0: true
            };
    } else {
      return {
              TAG: /* BoolV */1,
              _0: false
            };
    }
  } else {
    return Pervasives.failwith("must have two numbers to use >=");
  }
}

function equal(nums) {
  if (!nums) {
    return Pervasives.failwith("must have two numbers to use =");
  }
  var a = nums.hd;
  if (a.TAG !== /* NumV */0) {
    return Pervasives.failwith("must have two numbers to use =");
  }
  var match = nums.tl;
  if (!match) {
    return Pervasives.failwith("must have two numbers to use =");
  }
  var b = match.hd;
  if (b.TAG === /* NumV */0 && !match.tl) {
    if (a._0 === b._0) {
      return {
              TAG: /* BoolV */1,
              _0: true
            };
    } else {
      return {
              TAG: /* BoolV */1,
              _0: false
            };
    }
  } else {
    return Pervasives.failwith("must have two numbers to use =");
  }
}

function isItANumber(data) {
  if (data) {
    if (data.hd.TAG === /* NumV */0) {
      if (data.tl) {
        return Pervasives.failwith("wrong number of arguments");
      } else {
        return {
                TAG: /* BoolV */1,
                _0: true
              };
      }
    } else if (data.tl) {
      return Pervasives.failwith("wrong number of arguments");
    } else {
      return {
              TAG: /* BoolV */1,
              _0: false
            };
    }
  } else {
    return Pervasives.failwith("wrong number of arguments");
  }
}

function isItZero(input) {
  if (!input) {
    return Pervasives.failwith("can only use zero? on ints");
  }
  var match = input.hd;
  if (match.TAG === /* NumV */0) {
    if (match._0 !== 0) {
      if (input.tl) {
        return Pervasives.failwith("can only use zero? on ints");
      } else {
        return {
                TAG: /* BoolV */1,
                _0: false
              };
      }
    } else if (input.tl) {
      return Pervasives.failwith("can only use zero? on ints");
    } else {
      return {
              TAG: /* BoolV */1,
              _0: true
            };
    }
  } else {
    return Pervasives.failwith("can only use zero? on ints");
  }
}

function first(listy) {
  if (!listy) {
    return Pervasives.failwith("cannot call first on a non-list");
  }
  var match = listy.hd;
  if (match.TAG !== /* ListV */2) {
    return Pervasives.failwith("cannot call first on a non-list");
  }
  var match$1 = match._0;
  if (match$1) {
    if (listy.tl) {
      return Pervasives.failwith("cannot call first on a non-list");
    } else {
      return match$1.hd;
    }
  } else if (listy.tl) {
    return Pervasives.failwith("cannot call first on a non-list");
  } else {
    return Pervasives.failwith("cannot call first on an empty list");
  }
}

function rest(listy) {
  if (!listy) {
    return Pervasives.failwith("cannot call rest on a non-list");
  }
  var match = listy.hd;
  if (match.TAG !== /* ListV */2) {
    return Pervasives.failwith("cannot call rest on a non-list");
  }
  var match$1 = match._0;
  if (match$1) {
    if (listy.tl) {
      return Pervasives.failwith("cannot call rest on a non-list");
    } else {
      return {
              TAG: /* ListV */2,
              _0: match$1.tl
            };
    }
  } else if (listy.tl) {
    return Pervasives.failwith("cannot call rest on a non-list");
  } else {
    return Pervasives.failwith("cannot call rest on an empty list");
  }
}

function cons(lst) {
  if (!lst) {
    return Pervasives.failwith("cons expression must contain item, then ListV");
  }
  var match = lst.tl;
  if (!match) {
    return Pervasives.failwith("cons expression must contain item, then ListV");
  }
  var listy = match.hd;
  if (listy.TAG === /* ListV */2 && !match.tl) {
    return {
            TAG: /* ListV */2,
            _0: {
              hd: lst.hd,
              tl: listy._0
            }
          };
  } else {
    return Pervasives.failwith("cons expression must contain item, then ListV");
  }
}

function istItEmpty(listy) {
  if (!listy) {
    return Pervasives.failwith("cannot call empty? on a non-list");
  }
  var match = listy.hd;
  if (match.TAG === /* ListV */2) {
    if (match._0) {
      if (listy.tl) {
        return Pervasives.failwith("cannot call empty? on a non-list");
      } else {
        return {
                TAG: /* BoolV */1,
                _0: false
              };
      }
    } else if (listy.tl) {
      return Pervasives.failwith("cannot call empty? on a non-list");
    } else {
      return {
              TAG: /* BoolV */1,
              _0: true
            };
    }
  } else {
    return Pervasives.failwith("cannot call empty? on a non-list");
  }
}

function isItCons(listy) {
  if (!listy) {
    return Pervasives.failwith("cannot call cons? on a non-list");
  }
  var match = listy.hd;
  if (match.TAG === /* ListV */2) {
    if (match._0) {
      if (listy.tl) {
        return Pervasives.failwith("cannot call cons? on a non-list");
      } else {
        return {
                TAG: /* BoolV */1,
                _0: true
              };
      }
    } else if (listy.tl) {
      return Pervasives.failwith("cannot call cons? on a non-list");
    } else {
      return {
              TAG: /* BoolV */1,
              _0: false
            };
    }
  } else {
    return Pervasives.failwith("cannot call cons? on a non-list");
  }
}

function myNot(pred) {
  if (!pred) {
    return Pervasives.failwith("not can only be called on boolean values");
  }
  var match = pred.hd;
  if (match.TAG === /* BoolV */1) {
    if (match._0) {
      if (pred.tl) {
        return Pervasives.failwith("not can only be called on boolean values");
      } else {
        return {
                TAG: /* BoolV */1,
                _0: false
              };
      }
    } else if (pred.tl) {
      return Pervasives.failwith("not can only be called on boolean values");
    } else {
      return {
              TAG: /* BoolV */1,
              _0: true
            };
    }
  } else {
    return Pervasives.failwith("not can only be called on boolean values");
  }
}

function equalQuery(_data) {
  while(true) {
    var data = _data;
    if (!data) {
      return Pervasives.failwith("equal? can only compare two NumVs, BoolVs, or ListVs");
    }
    var a = data.hd;
    switch (a.TAG | 0) {
      case /* NumV */0 :
          var match = data.tl;
          if (!match) {
            return Pervasives.failwith("equal? can only compare two NumVs, BoolVs, or ListVs");
          }
          var b = match.hd;
          if (b.TAG === /* NumV */0) {
            if (match.tl) {
              return Pervasives.failwith("equal? can only compare two NumVs, BoolVs, or ListVs");
            } else if (a._0 === b._0) {
              return {
                      TAG: /* BoolV */1,
                      _0: true
                    };
            } else {
              return {
                      TAG: /* BoolV */1,
                      _0: false
                    };
            }
          }
          break;
      case /* BoolV */1 :
          var match$1 = data.tl;
          if (!match$1) {
            return Pervasives.failwith("equal? can only compare two NumVs, BoolVs, or ListVs");
          }
          var b$1 = match$1.hd;
          if (b$1.TAG === /* BoolV */1) {
            if (match$1.tl) {
              return Pervasives.failwith("equal? can only compare two NumVs, BoolVs, or ListVs");
            } else if (a._0 === b$1._0) {
              return {
                      TAG: /* BoolV */1,
                      _0: true
                    };
            } else {
              return {
                      TAG: /* BoolV */1,
                      _0: false
                    };
            }
          }
          break;
      case /* ListV */2 :
          var match$2 = data.tl;
          if (!match$2) {
            return Pervasives.failwith("equal? can only compare two NumVs, BoolVs, or ListVs");
          }
          var lst2 = match$2.hd;
          if (lst2.TAG === /* ListV */2) {
            if (match$2.tl) {
              return Pervasives.failwith("equal? can only compare two NumVs, BoolVs, or ListVs");
            }
            var lst2$1 = lst2._0;
            var lst1 = a._0;
            if (!lst1) {
              if (lst2$1) {
                return {
                        TAG: /* BoolV */1,
                        _0: false
                      };
              } else {
                return {
                        TAG: /* BoolV */1,
                        _0: true
                      };
              }
            }
            if (!lst2$1) {
              return {
                      TAG: /* BoolV */1,
                      _0: false
                    };
            }
            var b$2 = equalQuery({
                  hd: lst1.hd,
                  tl: {
                    hd: lst2$1.hd,
                    tl: /* [] */0
                  }
                });
            if (b$2.TAG === /* BoolV */1) {
              if (!b$2._0) {
                return {
                        TAG: /* BoolV */1,
                        _0: false
                      };
              }
              _data = {
                hd: {
                  TAG: /* ListV */2,
                  _0: lst1.tl
                },
                tl: {
                  hd: {
                    TAG: /* ListV */2,
                    _0: lst2$1.tl
                  },
                  tl: /* [] */0
                }
              };
              continue ;
            }
            throw {
                  RE_EXN_ID: "Match_failure",
                  _1: [
                    "Rackette.re",
                    324,
                    12
                  ],
                  Error: new Error()
                };
          }
          break;
      case /* BuiltinV */3 :
      case /* ClosureV */4 :
          break;
      
    }
    var match$3 = data.tl;
    if (match$3 && !match$3.tl) {
      return {
              TAG: /* BoolV */1,
              _0: false
            };
    } else {
      return Pervasives.failwith("equal? can only compare two NumVs, BoolVs, or ListVs");
    }
  };
}

var initialTle_0 = [
  /* Name */{
    _0: "+"
  },
  {
    TAG: /* BuiltinV */3,
    _0: {
      printedRep: "<builtin-proc-+>",
      bProc: plus
    }
  }
];

var initialTle_1 = {
  hd: [
    /* Name */{
      _0: "-"
    },
    {
      TAG: /* BuiltinV */3,
      _0: {
        printedRep: "<builtin-proc-->",
        bProc: minus
      }
    }
  ],
  tl: {
    hd: [
      /* Name */{
        _0: "*"
      },
      {
        TAG: /* BuiltinV */3,
        _0: {
          printedRep: "<builtin-proc-*>",
          bProc: times
        }
      }
    ],
    tl: {
      hd: [
        /* Name */{
          _0: "/"
        },
        {
          TAG: /* BuiltinV */3,
          _0: {
            printedRep: "<builtin-proc-/>",
            bProc: divide
          }
        }
      ],
      tl: {
        hd: [
          /* Name */{
            _0: "remainder"
          },
          {
            TAG: /* BuiltinV */3,
            _0: {
              printedRep: "<builtin-proc-remainder>",
              bProc: remainder
            }
          }
        ],
        tl: {
          hd: [
            /* Name */{
              _0: "="
            },
            {
              TAG: /* BuiltinV */3,
              _0: {
                printedRep: "<builtin-proc-=>",
                bProc: equal
              }
            }
          ],
          tl: {
            hd: [
              /* Name */{
                _0: "<"
              },
              {
                TAG: /* BuiltinV */3,
                _0: {
                  printedRep: "<builtin-proc-<>",
                  bProc: lessThan
                }
              }
            ],
            tl: {
              hd: [
                /* Name */{
                  _0: ">"
                },
                {
                  TAG: /* BuiltinV */3,
                  _0: {
                    printedRep: "<builtin-proc->>",
                    bProc: greaterThan
                  }
                }
              ],
              tl: {
                hd: [
                  /* Name */{
                    _0: "<="
                  },
                  {
                    TAG: /* BuiltinV */3,
                    _0: {
                      printedRep: "<builtin-proc-<=>",
                      bProc: lessThanEqualTo
                    }
                  }
                ],
                tl: {
                  hd: [
                    /* Name */{
                      _0: ">="
                    },
                    {
                      TAG: /* BuiltinV */3,
                      _0: {
                        printedRep: "<builtin-proc->=>",
                        bProc: greaterThanEqualTo
                      }
                    }
                  ],
                  tl: {
                    hd: [
                      /* Name */{
                        _0: "equal?"
                      },
                      {
                        TAG: /* BuiltinV */3,
                        _0: {
                          printedRep: "<builtin-proc-equal?>",
                          bProc: equalQuery
                        }
                      }
                    ],
                    tl: {
                      hd: [
                        /* Name */{
                          _0: "number?"
                        },
                        {
                          TAG: /* BuiltinV */3,
                          _0: {
                            printedRep: "<builtin-proc-number?>",
                            bProc: isItANumber
                          }
                        }
                      ],
                      tl: {
                        hd: [
                          /* Name */{
                            _0: "zero?"
                          },
                          {
                            TAG: /* BuiltinV */3,
                            _0: {
                              printedRep: "<builtin-proc-zero?>",
                              bProc: isItZero
                            }
                          }
                        ],
                        tl: {
                          hd: [
                            /* Name */{
                              _0: "cons"
                            },
                            {
                              TAG: /* BuiltinV */3,
                              _0: {
                                printedRep: "<builtin-proc-cons>",
                                bProc: cons
                              }
                            }
                          ],
                          tl: {
                            hd: [
                              /* Name */{
                                _0: "first"
                              },
                              {
                                TAG: /* BuiltinV */3,
                                _0: {
                                  printedRep: "<builtin-proc-first>",
                                  bProc: first
                                }
                              }
                            ],
                            tl: {
                              hd: [
                                /* Name */{
                                  _0: "rest"
                                },
                                {
                                  TAG: /* BuiltinV */3,
                                  _0: {
                                    printedRep: "<builtin-proc-rest>",
                                    bProc: rest
                                  }
                                }
                              ],
                              tl: {
                                hd: [
                                  /* Name */{
                                    _0: "empty?"
                                  },
                                  {
                                    TAG: /* BuiltinV */3,
                                    _0: {
                                      printedRep: "<builtin-proc-empty?>",
                                      bProc: istItEmpty
                                    }
                                  }
                                ],
                                tl: {
                                  hd: [
                                    /* Name */{
                                      _0: "cons?"
                                    },
                                    {
                                      TAG: /* BuiltinV */3,
                                      _0: {
                                        printedRep: "<builtin-proc-cons?>",
                                        bProc: isItCons
                                      }
                                    }
                                  ],
                                  tl: {
                                    hd: [
                                      /* Name */{
                                        _0: "not"
                                      },
                                      {
                                        TAG: /* BuiltinV */3,
                                        _0: {
                                          printedRep: "<builtin-proc-not>",
                                          bProc: myNot
                                        }
                                      }
                                    ],
                                    tl: /* [] */0
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
  }
};

var initialTle = {
  hd: initialTle_0,
  tl: initialTle_1
};

function parseExpression(kronkrete) {
  var letPairHelper = function (pairs) {
    if (!pairs) {
      return /* [] */0;
    }
    var match = pairs.hd;
    switch (match.TAG | 0) {
      case /* NumberC */0 :
      case /* SymbolC */1 :
          return Pervasives.failwith("improper let expression syntax");
      case /* ListC */2 :
          var match$1 = match._0;
          if (!match$1) {
            return Pervasives.failwith("improper let expression syntax");
          }
          var n = match$1.hd;
          switch (n.TAG | 0) {
            case /* SymbolC */1 :
                var match$2 = match$1.tl;
                if (!match$2) {
                  return Pervasives.failwith("improper let expression syntax");
                }
                if (match$2.tl) {
                  return Pervasives.failwith("improper let expression syntax");
                }
                var tl = pairs.tl;
                var exp = match$2.hd;
                var n$1 = n._0;
                if (tl) {
                  return {
                          hd: {
                            pairName: /* Name */{
                              _0: n$1
                            },
                            pairExpr: parseExpression(exp)
                          },
                          tl: letPairHelper(tl)
                        };
                } else {
                  return {
                          hd: {
                            pairName: /* Name */{
                              _0: n$1
                            },
                            pairExpr: parseExpression(exp)
                          },
                          tl: /* [] */0
                        };
                }
            case /* NumberC */0 :
            case /* ListC */2 :
                return Pervasives.failwith("improper let expression syntax");
            
          }
      
    }
  };
  var condParseHelper = function (tail) {
    if (!tail) {
      return Pervasives.failwith("cond must be followed by at least one condition/result pair.");
    }
    var match = tail.hd;
    switch (match.TAG | 0) {
      case /* NumberC */0 :
      case /* SymbolC */1 :
          return Pervasives.failwith("cond must be followed by at least one condition/result pair.");
      case /* ListC */2 :
          var match$1 = match._0;
          if (!match$1) {
            return Pervasives.failwith("cond must be followed by at least one condition/result pair.");
          }
          var match$2 = match$1.tl;
          if (!match$2) {
            return Pervasives.failwith("cond must be followed by at least one condition/result pair.");
          }
          if (match$2.tl) {
            return Pervasives.failwith("cond must be followed by at least one condition/result pair.");
          }
          var tl = tail.tl;
          var exp = match$2.hd;
          var pred = match$1.hd;
          if (tl) {
            return {
                    hd: {
                      conditionExpr: parseExpression(pred),
                      resultExpr: parseExpression(exp)
                    },
                    tl: condParseHelper(tl)
                  };
          } else {
            return {
                    hd: {
                      conditionExpr: parseExpression(pred),
                      resultExpr: parseExpression(exp)
                    },
                    tl: /* [] */0
                  };
          }
      
    }
  };
  var lambdaHelper = function (names) {
    if (!names) {
      return /* [] */0;
    }
    var hd = names.hd;
    switch (hd.TAG | 0) {
      case /* SymbolC */1 :
          var tl = names.tl;
          var hd$1 = hd._0;
          if (tl) {
            return {
                    hd: /* Name */{
                      _0: hd$1
                    },
                    tl: lambdaHelper(tl)
                  };
          } else {
            return {
                    hd: /* Name */{
                      _0: hd$1
                    },
                    tl: /* [] */0
                  };
          }
      case /* NumberC */0 :
      case /* ListC */2 :
          return Pervasives.failwith("lambda catchall error for pattern matching");
      
    }
  };
  switch (kronkrete.TAG | 0) {
    case /* NumberC */0 :
        return {
                TAG: /* NumE */0,
                _0: kronkrete._0
              };
    case /* SymbolC */1 :
        var str = kronkrete._0;
        switch (str) {
          case "empty" :
              return /* EmptyE */0;
          case "false" :
              return {
                      TAG: /* BoolE */1,
                      _0: false
                    };
          case "true" :
              return {
                      TAG: /* BoolE */1,
                      _0: true
                    };
          default:
            switch (str) {
              case "and" :
              case "cond" :
              case "define" :
              case "if" :
              case "lambda" :
              case "let" :
              case "or" :
                  return Pervasives.failwith("parseExpression reserved keyword");
              default:
                return {
                        TAG: /* NameE */2,
                        _0: /* Name */{
                          _0: str
                        }
                      };
            }
        }
    case /* ListC */2 :
        var n = kronkrete._0;
        if (!n) {
          return Pervasives.failwith("cannot enter empty program");
        }
        var match = n.hd;
        switch (match.TAG | 0) {
          case /* SymbolC */1 :
              switch (match._0) {
                case "and" :
                    var match$1 = n.tl;
                    if (!match$1) {
                      return Pervasives.failwith("and must be followed by two boolean expressions");
                    }
                    var match$2 = match$1.tl;
                    if (match$2 && !match$2.tl) {
                      return {
                              TAG: /* AndE */3,
                              _0: parseExpression(match$1.hd),
                              _1: parseExpression(match$2.hd)
                            };
                    } else {
                      return Pervasives.failwith("and must be followed by two boolean expressions");
                    }
                case "cond" :
                    return {
                            TAG: /* CondE */6,
                            _0: condParseHelper(n.tl)
                          };
                case "if" :
                    var match$3 = n.tl;
                    if (!match$3) {
                      return Pervasives.failwith("if statements must have a predicate followed by two expressions");
                    }
                    var match$4 = match$3.tl;
                    if (!match$4) {
                      return Pervasives.failwith("if statements must have a predicate followed by two expressions");
                    }
                    var match$5 = match$4.tl;
                    if (match$5 && !match$5.tl) {
                      return {
                              TAG: /* IfE */5,
                              _0: {
                                boolExpr: parseExpression(match$3.hd),
                                trueExpr: parseExpression(match$4.hd),
                                falseExpr: parseExpression(match$5.hd)
                              }
                            };
                    } else {
                      return Pervasives.failwith("if statements must have a predicate followed by two expressions");
                    }
                case "lambda" :
                    var match$6 = n.tl;
                    if (!match$6) {
                      return Pervasives.failwith("lambda expressions must contain a list of names followed by an list of expressions");
                    }
                    var names = match$6.hd;
                    switch (names.TAG | 0) {
                      case /* NumberC */0 :
                      case /* SymbolC */1 :
                          return Pervasives.failwith("lambda expressions must contain a list of names followed by an list of expressions");
                      case /* ListC */2 :
                          var match$7 = match$6.tl;
                          if (match$7 && !match$7.tl) {
                            return {
                                    TAG: /* LambdaE */7,
                                    _0: {
                                      nameList: lambdaHelper(names._0),
                                      lambdaBody: parseExpression(match$7.hd)
                                    }
                                  };
                          } else {
                            return Pervasives.failwith("lambda expressions must contain a list of names followed by an list of expressions");
                          }
                      
                    }
                case "let" :
                    var match$8 = n.tl;
                    if (!match$8) {
                      return Pervasives.failwith("let expressions must contain a list of one or more let pairs and a list of one or more expressions");
                    }
                    var letPairs = match$8.hd;
                    switch (letPairs.TAG | 0) {
                      case /* NumberC */0 :
                      case /* SymbolC */1 :
                          return Pervasives.failwith("let expressions must contain a list of one or more let pairs and a list of one or more expressions");
                      case /* ListC */2 :
                          var match$9 = match$8.tl;
                          if (match$9 && !match$9.tl) {
                            return {
                                    TAG: /* LetE */8,
                                    _0: {
                                      letPairs: letPairHelper(letPairs._0),
                                      letBody: parseExpression(match$9.hd)
                                    }
                                  };
                          } else {
                            return Pervasives.failwith("let expressions must contain a list of one or more let pairs and a list of one or more expressions");
                          }
                      
                    }
                case "or" :
                    var match$10 = n.tl;
                    if (!match$10) {
                      return Pervasives.failwith("or must be followed by two boolean expressions");
                    }
                    var match$11 = match$10.tl;
                    if (match$11 && !match$11.tl) {
                      return {
                              TAG: /* OrE */4,
                              _0: parseExpression(match$10.hd),
                              _1: parseExpression(match$11.hd)
                            };
                    } else {
                      return Pervasives.failwith("or must be followed by two boolean expressions");
                    }
                default:
                  return {
                          TAG: /* ApplicationE */9,
                          _0: List.map(parseExpression, n)
                        };
              }
          case /* NumberC */0 :
          case /* ListC */2 :
              return {
                      TAG: /* ApplicationE */9,
                      _0: List.map(parseExpression, n)
                    };
          
        }
    
  }
}

function parseDefinition(concrete) {
  switch (concrete.TAG | 0) {
    case /* NumberC */0 :
    case /* SymbolC */1 :
        return Pervasives.failwith("definition has invalid format");
    case /* ListC */2 :
        var match = concrete._0;
        if (!match) {
          return Pervasives.failwith("definition has invalid format");
        }
        var match$1 = match.hd;
        switch (match$1.TAG | 0) {
          case /* SymbolC */1 :
              if (match$1._0 !== "define") {
                return Pervasives.failwith("definition has invalid format");
              }
              var match$2 = match.tl;
              if (!match$2) {
                return Pervasives.failwith("definition has invalid format");
              }
              var str = match$2.hd;
              switch (str.TAG | 0) {
                case /* SymbolC */1 :
                    var match$3 = match$2.tl;
                    var str$1 = str._0;
                    if (!match$3) {
                      return Pervasives.failwith("definition must be followed by an expression");
                    }
                    if (match$3.tl) {
                      return Pervasives.failwith("definition must be followed by an expression");
                    }
                    switch (str$1) {
                      case "and" :
                      case "cond" :
                      case "define" :
                      case "empty" :
                      case "false" :
                      case "if" :
                      case "lambda" :
                      case "let" :
                      case "or" :
                      case "true" :
                          return Pervasives.failwith("cannot redefine keyword");
                      default:
                        return [
                                /* Name */{
                                  _0: str$1
                                },
                                parseExpression(match$3.hd)
                              ];
                    }
                case /* NumberC */0 :
                case /* ListC */2 :
                    return Pervasives.failwith("definition has invalid format");
                
              }
          case /* NumberC */0 :
          case /* ListC */2 :
              return Pervasives.failwith("definition has invalid format");
          
        }
    
  }
}

function parsePiece(input) {
  switch (input.TAG | 0) {
    case /* NumberC */0 :
    case /* SymbolC */1 :
        return {
                TAG: /* Expression */1,
                _0: parseExpression(input)
              };
    case /* ListC */2 :
        var match = input._0;
        if (!match) {
          return {
                  TAG: /* Expression */1,
                  _0: parseExpression(input)
                };
        }
        var match$1 = match.hd;
        switch (match$1.TAG | 0) {
          case /* SymbolC */1 :
              if (match$1._0 === "define") {
                return {
                        TAG: /* Definition */0,
                        _0: parseDefinition(input)
                      };
              } else {
                return {
                        TAG: /* Expression */1,
                        _0: parseExpression(input)
                      };
              }
          case /* NumberC */0 :
          case /* ListC */2 :
              return {
                      TAG: /* Expression */1,
                      _0: parseExpression(input)
                    };
          
        }
    
  }
}

function parse(input) {
  return List.map(parsePiece, input);
}

function lookup(_env, n) {
  while(true) {
    var env = _env;
    if (!env) {
      return false;
    }
    if (Caml_obj.caml_equal(n, /* Name */{
            _0: env.hd[0]._0
          })) {
      return true;
    }
    _env = env.tl;
    continue ;
  };
}

function lookupVal(_env, n) {
  while(true) {
    var env = _env;
    if (!env) {
      return Pervasives.failwith("name not yet bound to value");
    }
    var match = env.hd;
    if (n._0 === match[0]._0) {
      return match[1];
    }
    _env = env.tl;
    continue ;
  };
}

function lambdaEHelper(_names) {
  while(true) {
    var names = _names;
    if (!names) {
      return false;
    }
    var tl = names.tl;
    if (List.mem(names.hd, tl)) {
      return true;
    }
    _names = tl;
    continue ;
  };
}

function letEDuplicate(pairs) {
  if (pairs) {
    return {
            hd: pairs.hd.pairName,
            tl: letEDuplicate(pairs.tl)
          };
  } else {
    return /* [] */0;
  }
}

function $$eval(tle, _env, _expr) {
  while(true) {
    var expr = _expr;
    var env = _env;
    if (typeof expr === "number") {
      return {
              TAG: /* ListV */2,
              _0: /* [] */0
            };
    }
    switch (expr.TAG | 0) {
      case /* NumE */0 :
          return {
                  TAG: /* NumV */0,
                  _0: expr._0
                };
      case /* BoolE */1 :
          return {
                  TAG: /* BoolV */1,
                  _0: expr._0
                };
      case /* NameE */2 :
          return lookupVal(Pervasives.$at(env, tle), /* Name */{
                      _0: expr._0._0
                    });
      case /* AndE */3 :
          var evalExp1 = $$eval(tle, env, expr._0);
          if (evalExp1.TAG !== /* BoolV */1) {
            return Pervasives.failwith("the first clause of an and must evaluate to a boolean");
          }
          if (!evalExp1._0) {
            return {
                    TAG: /* BoolV */1,
                    _0: false
                  };
          }
          var evalExp2 = $$eval(tle, env, expr._1);
          if (evalExp2.TAG === /* BoolV */1) {
            if (evalExp2._0) {
              return {
                      TAG: /* BoolV */1,
                      _0: true
                    };
            } else {
              return {
                      TAG: /* BoolV */1,
                      _0: false
                    };
            }
          } else {
            return Pervasives.failwith("the second clause of an and must evaluate to a boolean");
          }
      case /* OrE */4 :
          var evalExp1$1 = $$eval(tle, env, expr._0);
          if (evalExp1$1.TAG !== /* BoolV */1) {
            return Pervasives.failwith("the first clause of or must evaluate to a boolean");
          }
          if (evalExp1$1._0) {
            return {
                    TAG: /* BoolV */1,
                    _0: true
                  };
          }
          var evalExp2$1 = $$eval(tle, env, expr._1);
          if (evalExp2$1.TAG === /* BoolV */1) {
            if (evalExp2$1._0) {
              return {
                      TAG: /* BoolV */1,
                      _0: true
                    };
            } else {
              return {
                      TAG: /* BoolV */1,
                      _0: false
                    };
            }
          } else {
            return Pervasives.failwith("the second clause of or must evaluate to a boolean");
          }
      case /* IfE */5 :
          var match = expr._0;
          var a = $$eval(tle, env, match.boolExpr);
          if (a.TAG !== /* BoolV */1) {
            return Pervasives.failwith("first condition of if expression must evaluate to boolean");
          }
          if (a._0) {
            _expr = match.trueExpr;
            continue ;
          }
          _expr = match.falseExpr;
          continue ;
      case /* CondE */6 :
          var match$1 = expr._0;
          if (!match$1) {
            return {
                    TAG: /* NumV */0,
                    _0: -1234
                  };
          }
          var match$2 = match$1.hd;
          var match$3 = $$eval(tle, env, match$2.conditionExpr);
          if (match$3.TAG !== /* BoolV */1) {
            return Pervasives.failwith("condition expressions must evaluate to true/false values");
          }
          if (match$3._0) {
            _expr = match$2.resultExpr;
            continue ;
          }
          _expr = {
            TAG: /* CondE */6,
            _0: match$1.tl
          };
          continue ;
      case /* LambdaE */7 :
          var match$4 = expr._0;
          var namez = match$4.nameList;
          if (lambdaEHelper(namez)) {
            return Pervasives.failwith("lambda expression can't have duplicate arg names");
          } else {
            return {
                    TAG: /* ClosureV */4,
                    _0: {
                      cNameList: namez,
                      cExpr: match$4.lambdaBody,
                      cEnv: env
                    }
                  };
          }
      case /* LetE */8 :
          var match$5 = expr._0;
          var pairs = match$5.letPairs;
          var letEHelper = (function(pairs){
          return function letEHelper(tle, _env, _lp) {
            while(true) {
              var lp = _lp;
              var env = _env;
              if (lambdaEHelper(letEDuplicate(pairs))) {
                return Pervasives.failwith("cannot have duplicate names in letPairs");
              }
              if (!lp) {
                return env;
              }
              var match = lp.hd;
              _lp = lp.tl;
              _env = {
                hd: [
                  match.pairName,
                  $$eval(tle, env, match.pairExpr)
                ],
                tl: env
              };
              continue ;
            };
          }
          }(pairs));
          _expr = match$5.letBody;
          _env = letEHelper(tle, env, pairs);
          continue ;
      case /* ApplicationE */9 :
          var p = List.map((function(env){
              return function (expr) {
                return $$eval(tle, env, expr);
              }
              }(env)), expr._0);
          if (!p) {
            return Pervasives.failwith("Application expression must start with a procedure");
          }
          var match$6 = p.hd;
          switch (match$6.TAG | 0) {
            case /* BuiltinV */3 :
                return Curry._1(match$6._0.bProc, p.tl);
            case /* ClosureV */4 :
                var match$7 = match$6._0;
                var bindHelper = function (lst, tl) {
                  if (lst) {
                    if (tl) {
                      return {
                              hd: [
                                lst.hd,
                                tl.hd
                              ],
                              tl: bindHelper(lst.tl, tl.tl)
                            };
                    } else {
                      return Pervasives.failwith("must have same number of formals and actuals");
                    }
                  } else if (tl) {
                    return Pervasives.failwith("must have same number of formals and actuals");
                  } else {
                    return /* [] */0;
                  }
                };
                _expr = match$7.cExpr;
                _env = Pervasives.$at(bindHelper(match$7.cNameList, p.tl), match$7.cEnv);
                continue ;
            default:
              return Pervasives.failwith("Application expression must start with a procedure");
          }
      
    }
  };
}

function addDefinition(env, param) {
  var id = param[0];
  if (lookup(env, id)) {
    return Pervasives.failwith("cannot redefine names; name already used");
  } else {
    return {
            hd: [
              id,
              $$eval(env, /* [] */0, param[1])
            ],
            tl: env
          };
  }
}

function stringOfValue(aValue) {
  switch (aValue.TAG | 0) {
    case /* NumV */0 :
        return String(aValue._0);
    case /* BoolV */1 :
        return Pervasives.string_of_bool(aValue._0);
    case /* ListV */2 :
        return List.fold_left((function (base, e) {
                      return base + (" " + stringOfValue(e));
                    }), "(list", aValue._0) + ")";
    case /* BuiltinV */3 :
    case /* ClosureV */4 :
        return "#<procedure>";
    
  }
}

function $$process(pieces) {
  var processHelper = function (_tle, _pieces) {
    while(true) {
      var pieces = _pieces;
      var tle = _tle;
      if (!pieces) {
        return /* [] */0;
      }
      var d = pieces.hd;
      if (d.TAG !== /* Definition */0) {
        return {
                hd: $$eval(tle, /* [] */0, d._0),
                tl: processHelper(tle, pieces.tl)
              };
      }
      _pieces = pieces.tl;
      _tle = addDefinition(tle, d._0);
      continue ;
    };
  };
  return processHelper(initialTle, pieces);
}

function rackette(program) {
  return List.map(stringOfValue, $$process(List.map(parsePiece, Read$RacketteErrorless.Reader.readAll(program))));
}

CS17SetupRackette$RacketteErrorless.checkExpectExpression(parseExpression({
          TAG: /* SymbolC */1,
          _0: "empty"
        }), /* EmptyE */0, "parse empty expression");

CS17SetupRackette$RacketteErrorless.checkExpectExpression(parseExpression(Read$RacketteErrorless.Reader.read("empty")), /* EmptyE */0, "read and parse empty expression");

CS17SetupRackette$RacketteErrorless.checkExpectExpression(parseExpression({
          TAG: /* SymbolC */1,
          _0: "empty"
        }), /* EmptyE */0, "parseExpression on empty list");

CS17SetupRackette$RacketteErrorless.checkExpectExpression(parseExpression(Read$RacketteErrorless.Reader.read("empty")), /* EmptyE */0, "read and parseExpression on empty expression");

CS17SetupRackette$RacketteErrorless.checkExpectExpression(parseExpression({
          TAG: /* SymbolC */1,
          _0: "x"
        }), {
      TAG: /* NameE */2,
      _0: /* Name */{
        _0: "x"
      }
    }, "parseExpression on a name");

CS17SetupRackette$RacketteErrorless.checkExpectExpression(parseExpression(Read$RacketteErrorless.Reader.read("x")), {
      TAG: /* NameE */2,
      _0: /* Name */{
        _0: "x"
      }
    }, "read and parseExpression on a name");

CS17SetupRackette$RacketteErrorless.checkExpectExpression(parseExpression({
          TAG: /* NumberC */0,
          _0: 1
        }), {
      TAG: /* NumE */0,
      _0: 1
    }, "parseExpression on a number");

CS17SetupRackette$RacketteErrorless.checkExpectExpression(parseExpression(Read$RacketteErrorless.Reader.read("3")), {
      TAG: /* NumE */0,
      _0: 3
    }, "read and parseExpression on a number");

CS17SetupRackette$RacketteErrorless.checkExpectExpression(parseExpression({
          TAG: /* SymbolC */1,
          _0: "true"
        }), {
      TAG: /* BoolE */1,
      _0: true
    }, "parseExpression on boolean");

CS17SetupRackette$RacketteErrorless.checkExpectExpression(parseExpression(Read$RacketteErrorless.Reader.read("false")), {
      TAG: /* BoolE */1,
      _0: false
    }, "read and parseExpression on boolean");

CS17SetupRackette$RacketteErrorless.checkExpectExpression(parseExpression({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "+"
            },
            tl: {
              hd: {
                TAG: /* NumberC */0,
                _0: 1
              },
              tl: {
                hd: {
                  TAG: /* NumberC */0,
                  _0: 2
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* ApplicationE */9,
      _0: {
        hd: {
          TAG: /* NameE */2,
          _0: /* Name */{
            _0: "+"
          }
        },
        tl: {
          hd: {
            TAG: /* NumE */0,
            _0: 1
          },
          tl: {
            hd: {
              TAG: /* NumE */0,
              _0: 2
            },
            tl: /* [] */0
          }
        }
      }
    }, "parseExpression ListC to basic ApplicationE");

CS17SetupRackette$RacketteErrorless.checkExpectExpression(parseExpression(Read$RacketteErrorless.Reader.read("(+ 1 2)")), {
      TAG: /* ApplicationE */9,
      _0: {
        hd: {
          TAG: /* NameE */2,
          _0: /* Name */{
            _0: "+"
          }
        },
        tl: {
          hd: {
            TAG: /* NumE */0,
            _0: 1
          },
          tl: {
            hd: {
              TAG: /* NumE */0,
              _0: 2
            },
            tl: /* [] */0
          }
        }
      }
    }, "read and parseExpression basic ListC to ApplicationE");

CS17SetupRackette$RacketteErrorless.checkExpectExpression(parseExpression({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "and"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "true"
              },
              tl: {
                hd: {
                  TAG: /* SymbolC */1,
                  _0: "false"
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* AndE */3,
      _0: {
        TAG: /* BoolE */1,
        _0: true
      },
      _1: {
        TAG: /* BoolE */1,
        _0: false
      }
    }, "parseExpression for and");

CS17SetupRackette$RacketteErrorless.checkExpectExpression(parseExpression(Read$RacketteErrorless.Reader.read("(and true true)")), {
      TAG: /* AndE */3,
      _0: {
        TAG: /* BoolE */1,
        _0: true
      },
      _1: {
        TAG: /* BoolE */1,
        _0: true
      }
    }, "read and parseExpression for and");

CS17SetupRackette$RacketteErrorless.checkExpectExpression(parseExpression({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "or"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "true"
              },
              tl: {
                hd: {
                  TAG: /* SymbolC */1,
                  _0: "false"
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* OrE */4,
      _0: {
        TAG: /* BoolE */1,
        _0: true
      },
      _1: {
        TAG: /* BoolE */1,
        _0: false
      }
    }, "parseExpression for or");

CS17SetupRackette$RacketteErrorless.checkExpectExpression(parseExpression(Read$RacketteErrorless.Reader.read("(or false false)")), {
      TAG: /* OrE */4,
      _0: {
        TAG: /* BoolE */1,
        _0: false
      },
      _1: {
        TAG: /* BoolE */1,
        _0: false
      }
    }, "read and parseExpression for or");

CS17SetupRackette$RacketteErrorless.checkExpectExpression(parseExpression({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "if"
            },
            tl: {
              hd: {
                TAG: /* ListC */2,
                _0: {
                  hd: {
                    TAG: /* SymbolC */1,
                    _0: "<"
                  },
                  tl: {
                    hd: {
                      TAG: /* NumberC */0,
                      _0: 0
                    },
                    tl: {
                      hd: {
                        TAG: /* SymbolC */1,
                        _0: "x"
                      },
                      tl: /* [] */0
                    }
                  }
                }
              },
              tl: {
                hd: {
                  TAG: /* SymbolC */1,
                  _0: "x"
                },
                tl: {
                  hd: {
                    TAG: /* NumberC */0,
                    _0: 0
                  },
                  tl: /* [] */0
                }
              }
            }
          }
        }), {
      TAG: /* IfE */5,
      _0: {
        boolExpr: {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "<"
              }
            },
            tl: {
              hd: {
                TAG: /* NumE */0,
                _0: 0
              },
              tl: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "x"
                  }
                },
                tl: /* [] */0
              }
            }
          }
        },
        trueExpr: {
          TAG: /* NameE */2,
          _0: /* Name */{
            _0: "x"
          }
        },
        falseExpr: {
          TAG: /* NumE */0,
          _0: 0
        }
      }
    }, "parseExpression for if");

CS17SetupRackette$RacketteErrorless.checkExpectExpression(parseExpression(Read$RacketteErrorless.Reader.read("(if (< 0 x) x 0 )")), {
      TAG: /* IfE */5,
      _0: {
        boolExpr: {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "<"
              }
            },
            tl: {
              hd: {
                TAG: /* NumE */0,
                _0: 0
              },
              tl: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "x"
                  }
                },
                tl: /* [] */0
              }
            }
          }
        },
        trueExpr: {
          TAG: /* NameE */2,
          _0: /* Name */{
            _0: "x"
          }
        },
        falseExpr: {
          TAG: /* NumE */0,
          _0: 0
        }
      }
    }, "read and parseExpression for if");

CS17SetupRackette$RacketteErrorless.checkExpectExpression(parseExpression({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "cond"
            },
            tl: {
              hd: {
                TAG: /* ListC */2,
                _0: {
                  hd: {
                    TAG: /* SymbolC */1,
                    _0: "empty"
                  },
                  tl: {
                    hd: {
                      TAG: /* SymbolC */1,
                      _0: "empty"
                    },
                    tl: /* [] */0
                  }
                }
              },
              tl: /* [] */0
            }
          }
        }), {
      TAG: /* CondE */6,
      _0: {
        hd: {
          conditionExpr: /* EmptyE */0,
          resultExpr: /* EmptyE */0
        },
        tl: /* [] */0
      }
    }, "parseExpresion for cond");

CS17SetupRackette$RacketteErrorless.checkExpectExpression(parseExpression(Read$RacketteErrorless.Reader.read("(cond ((> x 1) x) ((<= x 1) 1))")), {
      TAG: /* CondE */6,
      _0: {
        hd: {
          conditionExpr: {
            TAG: /* ApplicationE */9,
            _0: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: ">"
                }
              },
              tl: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "x"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NumE */0,
                    _0: 1
                  },
                  tl: /* [] */0
                }
              }
            }
          },
          resultExpr: {
            TAG: /* NameE */2,
            _0: /* Name */{
              _0: "x"
            }
          }
        },
        tl: {
          hd: {
            conditionExpr: {
              TAG: /* ApplicationE */9,
              _0: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "<="
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: "x"
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* NumE */0,
                      _0: 1
                    },
                    tl: /* [] */0
                  }
                }
              }
            },
            resultExpr: {
              TAG: /* NumE */0,
              _0: 1
            }
          },
          tl: /* [] */0
        }
      }
    }, "read and parseExpression for cond");

CS17SetupRackette$RacketteErrorless.checkExpectExpression(parseExpression({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "lambda"
            },
            tl: {
              hd: {
                TAG: /* ListC */2,
                _0: {
                  hd: {
                    TAG: /* SymbolC */1,
                    _0: "x"
                  },
                  tl: /* [] */0
                }
              },
              tl: {
                hd: {
                  TAG: /* ListC */2,
                  _0: {
                    hd: {
                      TAG: /* SymbolC */1,
                      _0: "*"
                    },
                    tl: {
                      hd: {
                        TAG: /* SymbolC */1,
                        _0: "x"
                      },
                      tl: {
                        hd: {
                          TAG: /* NumberC */0,
                          _0: 1
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* LambdaE */7,
      _0: {
        nameList: {
          hd: /* Name */{
            _0: "x"
          },
          tl: /* [] */0
        },
        lambdaBody: {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "*"
              }
            },
            tl: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "x"
                }
              },
              tl: {
                hd: {
                  TAG: /* NumE */0,
                  _0: 1
                },
                tl: /* [] */0
              }
            }
          }
        }
      }
    }, "parseExpression for lambda");

CS17SetupRackette$RacketteErrorless.checkExpectExpression(parseExpression(Read$RacketteErrorless.Reader.read("(lambda (x y) (+ x y))")), {
      TAG: /* LambdaE */7,
      _0: {
        nameList: {
          hd: /* Name */{
            _0: "x"
          },
          tl: {
            hd: /* Name */{
              _0: "y"
            },
            tl: /* [] */0
          }
        },
        lambdaBody: {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "+"
              }
            },
            tl: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "x"
                }
              },
              tl: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "y"
                  }
                },
                tl: /* [] */0
              }
            }
          }
        }
      }
    }, "read and parseExpression lambda");

CS17SetupRackette$RacketteErrorless.checkExpectExpression(parseExpression({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "let"
            },
            tl: {
              hd: {
                TAG: /* ListC */2,
                _0: {
                  hd: {
                    TAG: /* ListC */2,
                    _0: {
                      hd: {
                        TAG: /* SymbolC */1,
                        _0: "x"
                      },
                      tl: {
                        hd: {
                          TAG: /* NumberC */0,
                          _0: 1
                        },
                        tl: /* [] */0
                      }
                    }
                  },
                  tl: /* [] */0
                }
              },
              tl: {
                hd: {
                  TAG: /* ListC */2,
                  _0: {
                    hd: {
                      TAG: /* SymbolC */1,
                      _0: "*"
                    },
                    tl: {
                      hd: {
                        TAG: /* SymbolC */1,
                        _0: "x"
                      },
                      tl: {
                        hd: {
                          TAG: /* NumberC */0,
                          _0: 5
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* LetE */8,
      _0: {
        letPairs: {
          hd: {
            pairName: /* Name */{
              _0: "x"
            },
            pairExpr: {
              TAG: /* NumE */0,
              _0: 1
            }
          },
          tl: /* [] */0
        },
        letBody: {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "*"
              }
            },
            tl: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "x"
                }
              },
              tl: {
                hd: {
                  TAG: /* NumE */0,
                  _0: 5
                },
                tl: /* [] */0
              }
            }
          }
        }
      }
    }, "parseExpression for let");

CS17SetupRackette$RacketteErrorless.checkExpectExpression(parseExpression(Read$RacketteErrorless.Reader.read("(let ((x 1) (y 3)) (+ x y) )")), {
      TAG: /* LetE */8,
      _0: {
        letPairs: {
          hd: {
            pairName: /* Name */{
              _0: "x"
            },
            pairExpr: {
              TAG: /* NumE */0,
              _0: 1
            }
          },
          tl: {
            hd: {
              pairName: /* Name */{
                _0: "y"
              },
              pairExpr: {
                TAG: /* NumE */0,
                _0: 3
              }
            },
            tl: /* [] */0
          }
        },
        letBody: {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "+"
              }
            },
            tl: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "x"
                }
              },
              tl: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "y"
                  }
                },
                tl: /* [] */0
              }
            }
          }
        }
      }
    }, "read and parseExpression let");

CS17SetupRackette$RacketteErrorless.checkExpectDefinition(parseDefinition(Read$RacketteErrorless.Reader.read("(define x 2)")), [
      /* Name */{
        _0: "x"
      },
      {
        TAG: /* NumE */0,
        _0: 2
      }
    ], "read and parseDefinition w/ name set to a number");

CS17SetupRackette$RacketteErrorless.checkExpectDefinition(parseDefinition({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "define"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "x"
              },
              tl: {
                hd: {
                  TAG: /* NumberC */0,
                  _0: 1
                },
                tl: /* [] */0
              }
            }
          }
        }), [
      /* Name */{
        _0: "x"
      },
      {
        TAG: /* NumE */0,
        _0: 1
      }
    ], "parseDefinition w/ name set to number");

CS17SetupRackette$RacketteErrorless.checkExpectDefinition(parseDefinition(Read$RacketteErrorless.Reader.read("(define x (+ 3 1))")), [
      /* Name */{
        _0: "x"
      },
      {
        TAG: /* ApplicationE */9,
        _0: {
          hd: {
            TAG: /* NameE */2,
            _0: /* Name */{
              _0: "+"
            }
          },
          tl: {
            hd: {
              TAG: /* NumE */0,
              _0: 3
            },
            tl: {
              hd: {
                TAG: /* NumE */0,
                _0: 1
              },
              tl: /* [] */0
            }
          }
        }
      }
    ], "read and parseDefinition w/ name set to a number");

CS17SetupRackette$RacketteErrorless.checkExpectDefinition(parseDefinition({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "define"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "x"
              },
              tl: {
                hd: {
                  TAG: /* ListC */2,
                  _0: {
                    hd: {
                      TAG: /* SymbolC */1,
                      _0: "/"
                    },
                    tl: {
                      hd: {
                        TAG: /* NumberC */0,
                        _0: 10
                      },
                      tl: {
                        hd: {
                          TAG: /* NumberC */0,
                          _0: 2
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                },
                tl: /* [] */0
              }
            }
          }
        }), [
      /* Name */{
        _0: "x"
      },
      {
        TAG: /* ApplicationE */9,
        _0: {
          hd: {
            TAG: /* NameE */2,
            _0: /* Name */{
              _0: "/"
            }
          },
          tl: {
            hd: {
              TAG: /* NumE */0,
              _0: 10
            },
            tl: {
              hd: {
                TAG: /* NumE */0,
                _0: 2
              },
              tl: /* [] */0
            }
          }
        }
      }
    ], "parseDefinition w/ name set to application");

CS17SetupRackette$RacketteErrorless.checkExpectDefinition(parseDefinition(Read$RacketteErrorless.Reader.read("(define y (cons 3 (cons 5 empty)))")), [
      /* Name */{
        _0: "y"
      },
      {
        TAG: /* ApplicationE */9,
        _0: {
          hd: {
            TAG: /* NameE */2,
            _0: /* Name */{
              _0: "cons"
            }
          },
          tl: {
            hd: {
              TAG: /* NumE */0,
              _0: 3
            },
            tl: {
              hd: {
                TAG: /* ApplicationE */9,
                _0: {
                  hd: {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: "cons"
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* NumE */0,
                      _0: 5
                    },
                    tl: {
                      hd: /* EmptyE */0,
                      tl: /* [] */0
                    }
                  }
                }
              },
              tl: /* [] */0
            }
          }
        }
      }
    ], "parseDefinition to list");

CS17SetupRackette$RacketteErrorless.checkExpectDefinition(parseDefinition(Read$RacketteErrorless.Reader.read("(define x true)")), [
      /* Name */{
        _0: "x"
      },
      {
        TAG: /* BoolE */1,
        _0: true
      }
    ], "read and parseDefinition w/ name set to a boolean");

CS17SetupRackette$RacketteErrorless.checkExpectAbstractProgramPiece(parsePiece(Read$RacketteErrorless.Reader.read("(define x true)")), {
      TAG: /* Definition */0,
      _0: [
        /* Name */{
          _0: "x"
        },
        {
          TAG: /* BoolE */1,
          _0: true
        }
      ]
    }, "read and parse piece on boolean definition");

CS17SetupRackette$RacketteErrorless.checkExpectAbstractProgramPiece(parsePiece({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "define"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "x"
              },
              tl: {
                hd: {
                  TAG: /* SymbolC */1,
                  _0: "false"
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* Definition */0,
      _0: [
        /* Name */{
          _0: "x"
        },
        {
          TAG: /* BoolE */1,
          _0: false
        }
      ]
    }, "parse piece w/ name set to boolean");

CS17SetupRackette$RacketteErrorless.checkExpectAbstractProgramPiece(parsePiece({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "define"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "x"
              },
              tl: {
                hd: {
                  TAG: /* SymbolC */1,
                  _0: "false"
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* Definition */0,
      _0: [
        /* Name */{
          _0: "x"
        },
        {
          TAG: /* BoolE */1,
          _0: false
        }
      ]
    }, "parse piece w/ name set to boolean");

CS17SetupRackette$RacketteErrorless.checkExpectAbstractProgramPiece({
      TAG: /* Expression */1,
      _0: parseExpression({
            TAG: /* NumberC */0,
            _0: 9
          })
    }, {
      TAG: /* Expression */1,
      _0: {
        TAG: /* NumE */0,
        _0: 9
      }
    }, "parse piece for num");

CS17SetupRackette$RacketteErrorless.checkExpectAbstractProgramPiece(parsePiece(Read$RacketteErrorless.Reader.read("9")), {
      TAG: /* Expression */1,
      _0: {
        TAG: /* NumE */0,
        _0: 9
      }
    }, "parse piece and read for num");

CS17SetupRackette$RacketteErrorless.checkExpectAbstractProgramPiece(parsePiece(Read$RacketteErrorless.Reader.read("true")), {
      TAG: /* Expression */1,
      _0: {
        TAG: /* BoolE */1,
        _0: true
      }
    }, "parse piece and read for num");

CS17SetupRackette$RacketteErrorless.checkExpectAbstractProgramPiece(parsePiece(Read$RacketteErrorless.Reader.read("empty")), {
      TAG: /* Expression */1,
      _0: /* EmptyE */0
    }, "parse piece and read for empty");

CS17SetupRackette$RacketteErrorless.checkExpectAbstractProgramPiece(parsePiece(Read$RacketteErrorless.Reader.read("x")), {
      TAG: /* Expression */1,
      _0: {
        TAG: /* NameE */2,
        _0: /* Name */{
          _0: "x"
        }
      }
    }, "parse piece and read for name");

CS17SetupRackette$RacketteErrorless.checkExpectAbstractProgramPiece({
      TAG: /* Expression */1,
      _0: parseExpression({
            TAG: /* SymbolC */1,
            _0: "x"
          })
    }, {
      TAG: /* Expression */1,
      _0: {
        TAG: /* NameE */2,
        _0: /* Name */{
          _0: "x"
        }
      }
    }, "parse piece for name");

CS17SetupRackette$RacketteErrorless.checkExpectAbstractProgramPiece(parsePiece(Read$RacketteErrorless.Reader.read("(and true false)")), {
      TAG: /* Expression */1,
      _0: {
        TAG: /* AndE */3,
        _0: {
          TAG: /* BoolE */1,
          _0: true
        },
        _1: {
          TAG: /* BoolE */1,
          _0: false
        }
      }
    }, "parse piece and read for and");

CS17SetupRackette$RacketteErrorless.checkExpectAbstractProgramPiece(parsePiece({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "and"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "true"
              },
              tl: {
                hd: {
                  TAG: /* SymbolC */1,
                  _0: "false"
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* Expression */1,
      _0: {
        TAG: /* AndE */3,
        _0: {
          TAG: /* BoolE */1,
          _0: true
        },
        _1: {
          TAG: /* BoolE */1,
          _0: false
        }
      }
    }, "parseExpression for and");

CS17SetupRackette$RacketteErrorless.checkExpectAbstractProgramPiece(parsePiece({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "or"
            },
            tl: {
              hd: {
                TAG: /* SymbolC */1,
                _0: "true"
              },
              tl: {
                hd: {
                  TAG: /* SymbolC */1,
                  _0: "false"
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* Expression */1,
      _0: {
        TAG: /* OrE */4,
        _0: {
          TAG: /* BoolE */1,
          _0: true
        },
        _1: {
          TAG: /* BoolE */1,
          _0: false
        }
      }
    }, "parse piece for or");

CS17SetupRackette$RacketteErrorless.checkExpectAbstractProgramPiece(parsePiece(Read$RacketteErrorless.Reader.read("(or false false)")), {
      TAG: /* Expression */1,
      _0: {
        TAG: /* OrE */4,
        _0: {
          TAG: /* BoolE */1,
          _0: false
        },
        _1: {
          TAG: /* BoolE */1,
          _0: false
        }
      }
    }, "read and parse piece for or");

CS17SetupRackette$RacketteErrorless.checkExpectAbstractProgramPiece(parsePiece({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "if"
            },
            tl: {
              hd: {
                TAG: /* ListC */2,
                _0: {
                  hd: {
                    TAG: /* SymbolC */1,
                    _0: "<"
                  },
                  tl: {
                    hd: {
                      TAG: /* NumberC */0,
                      _0: 0
                    },
                    tl: {
                      hd: {
                        TAG: /* SymbolC */1,
                        _0: "x"
                      },
                      tl: /* [] */0
                    }
                  }
                }
              },
              tl: {
                hd: {
                  TAG: /* SymbolC */1,
                  _0: "x"
                },
                tl: {
                  hd: {
                    TAG: /* NumberC */0,
                    _0: 0
                  },
                  tl: /* [] */0
                }
              }
            }
          }
        }), {
      TAG: /* Expression */1,
      _0: {
        TAG: /* IfE */5,
        _0: {
          boolExpr: {
            TAG: /* ApplicationE */9,
            _0: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "<"
                }
              },
              tl: {
                hd: {
                  TAG: /* NumE */0,
                  _0: 0
                },
                tl: {
                  hd: {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: "x"
                    }
                  },
                  tl: /* [] */0
                }
              }
            }
          },
          trueExpr: {
            TAG: /* NameE */2,
            _0: /* Name */{
              _0: "x"
            }
          },
          falseExpr: {
            TAG: /* NumE */0,
            _0: 0
          }
        }
      }
    }, "parse piece for if");

CS17SetupRackette$RacketteErrorless.checkExpectAbstractProgramPiece(parsePiece(Read$RacketteErrorless.Reader.read("(if (< 0 x) x 0 )")), {
      TAG: /* Expression */1,
      _0: {
        TAG: /* IfE */5,
        _0: {
          boolExpr: {
            TAG: /* ApplicationE */9,
            _0: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "<"
                }
              },
              tl: {
                hd: {
                  TAG: /* NumE */0,
                  _0: 0
                },
                tl: {
                  hd: {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: "x"
                    }
                  },
                  tl: /* [] */0
                }
              }
            }
          },
          trueExpr: {
            TAG: /* NameE */2,
            _0: /* Name */{
              _0: "x"
            }
          },
          falseExpr: {
            TAG: /* NumE */0,
            _0: 0
          }
        }
      }
    }, "read and parse piece for if");

CS17SetupRackette$RacketteErrorless.checkExpectAbstractProgramPiece(parsePiece({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "cond"
            },
            tl: {
              hd: {
                TAG: /* ListC */2,
                _0: {
                  hd: {
                    TAG: /* SymbolC */1,
                    _0: "empty"
                  },
                  tl: {
                    hd: {
                      TAG: /* SymbolC */1,
                      _0: "empty"
                    },
                    tl: /* [] */0
                  }
                }
              },
              tl: /* [] */0
            }
          }
        }), {
      TAG: /* Expression */1,
      _0: {
        TAG: /* CondE */6,
        _0: {
          hd: {
            conditionExpr: /* EmptyE */0,
            resultExpr: /* EmptyE */0
          },
          tl: /* [] */0
        }
      }
    }, "parse piece for cond");

CS17SetupRackette$RacketteErrorless.checkExpectAbstractProgramPiece(parsePiece(Read$RacketteErrorless.Reader.read("(cond ((> x 1) x) ((<= x 1) 1))")), {
      TAG: /* Expression */1,
      _0: {
        TAG: /* CondE */6,
        _0: {
          hd: {
            conditionExpr: {
              TAG: /* ApplicationE */9,
              _0: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: ">"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: "x"
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* NumE */0,
                      _0: 1
                    },
                    tl: /* [] */0
                  }
                }
              }
            },
            resultExpr: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "x"
              }
            }
          },
          tl: {
            hd: {
              conditionExpr: {
                TAG: /* ApplicationE */9,
                _0: {
                  hd: {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: "<="
                    }
                  },
                  tl: {
                    hd: {
                      TAG: /* NameE */2,
                      _0: /* Name */{
                        _0: "x"
                      }
                    },
                    tl: {
                      hd: {
                        TAG: /* NumE */0,
                        _0: 1
                      },
                      tl: /* [] */0
                    }
                  }
                }
              },
              resultExpr: {
                TAG: /* NumE */0,
                _0: 1
              }
            },
            tl: /* [] */0
          }
        }
      }
    }, "read and parsePiece for cond");

CS17SetupRackette$RacketteErrorless.checkExpectAbstractProgramPiece(parsePiece({
          TAG: /* ListC */2,
          _0: {
            hd: {
              TAG: /* SymbolC */1,
              _0: "lambda"
            },
            tl: {
              hd: {
                TAG: /* ListC */2,
                _0: {
                  hd: {
                    TAG: /* SymbolC */1,
                    _0: "y"
                  },
                  tl: /* [] */0
                }
              },
              tl: {
                hd: {
                  TAG: /* ListC */2,
                  _0: {
                    hd: {
                      TAG: /* SymbolC */1,
                      _0: "/"
                    },
                    tl: {
                      hd: {
                        TAG: /* SymbolC */1,
                        _0: "y"
                      },
                      tl: {
                        hd: {
                          TAG: /* NumberC */0,
                          _0: 10
                        },
                        tl: /* [] */0
                      }
                    }
                  }
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* Expression */1,
      _0: {
        TAG: /* LambdaE */7,
        _0: {
          nameList: {
            hd: /* Name */{
              _0: "y"
            },
            tl: /* [] */0
          },
          lambdaBody: {
            TAG: /* ApplicationE */9,
            _0: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "/"
                }
              },
              tl: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "y"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NumE */0,
                    _0: 10
                  },
                  tl: /* [] */0
                }
              }
            }
          }
        }
      }
    }, "parsePiece for lambda");

CS17SetupRackette$RacketteErrorless.checkExpectAbstractProgramPiece(parsePiece(Read$RacketteErrorless.Reader.read("(lambda (x y) (- x y))")), {
      TAG: /* Expression */1,
      _0: {
        TAG: /* LambdaE */7,
        _0: {
          nameList: {
            hd: /* Name */{
              _0: "x"
            },
            tl: {
              hd: /* Name */{
                _0: "y"
              },
              tl: /* [] */0
            }
          },
          lambdaBody: {
            TAG: /* ApplicationE */9,
            _0: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "-"
                }
              },
              tl: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "x"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NameE */2,
                    _0: /* Name */{
                      _0: "y"
                    }
                  },
                  tl: /* [] */0
                }
              }
            }
          }
        }
      }
    }, "read and parse piece lambda");

CS17SetupRackette$RacketteErrorless.checkExpectExpression(parseExpression(Read$RacketteErrorless.Reader.read("(let ((x 12) (y 2)) (remainder x y) )")), {
      TAG: /* LetE */8,
      _0: {
        letPairs: {
          hd: {
            pairName: /* Name */{
              _0: "x"
            },
            pairExpr: {
              TAG: /* NumE */0,
              _0: 12
            }
          },
          tl: {
            hd: {
              pairName: /* Name */{
                _0: "y"
              },
              pairExpr: {
                TAG: /* NumE */0,
                _0: 2
              }
            },
            tl: /* [] */0
          }
        },
        letBody: {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "remainder"
              }
            },
            tl: {
              hd: {
                TAG: /* NameE */2,
                _0: /* Name */{
                  _0: "x"
                }
              },
              tl: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "y"
                  }
                },
                tl: /* [] */0
              }
            }
          }
        }
      }
    }, "read and parse piece let");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("3"))), {
      TAG: /* NumV */0,
      _0: 3
    }, "eval and parse num");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval({
          hd: [
            /* Name */{
              _0: "x"
            },
            {
              TAG: /* NumV */0,
              _0: 3
            }
          ],
          tl: /* [] */0
        }, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("x"))), {
      TAG: /* NumV */0,
      _0: 3
    }, "eval a name to its value in the tle");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval({
          hd: [
            /* Name */{
              _0: "x"
            },
            {
              TAG: /* NumV */0,
              _0: 3
            }
          ],
          tl: /* [] */0
        }, {
          hd: [
            /* Name */{
              _0: "x"
            },
            {
              TAG: /* NumV */0,
              _0: 99
            }
          ],
          tl: /* [] */0
        }, parseExpression(Read$RacketteErrorless.Reader.read("x"))), {
      TAG: /* NumV */0,
      _0: 99
    }, "parse and eval a name to its value in the local environment");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("true"))), {
      TAG: /* BoolV */1,
      _0: true
    }, "eval and parse bool");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, {
          TAG: /* OrE */4,
          _0: {
            TAG: /* BoolE */1,
            _0: false
          },
          _1: {
            TAG: /* BoolE */1,
            _0: false
          }
        }), {
      TAG: /* BoolV */1,
      _0: false
    }, "eval or expression to a boolean");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("empty"))), {
      TAG: /* ListV */2,
      _0: /* [] */0
    }, "eval and parse empty list");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("(if (> 3 4) 3 (if false 6 7))"), {
      hd: "7",
      tl: /* [] */0
    }, "complex if statement ***************************");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("(+ 3 5)"))), {
      TAG: /* NumV */0,
      _0: 8
    }, "parsing and evaluating adding!");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("(- 10 5)"))), {
      TAG: /* NumV */0,
      _0: 5
    }, "parsing and eval subtracting!");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("(* 3 5)"))), {
      TAG: /* NumV */0,
      _0: 15
    }, "parse and eval mutliplying!");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("(/ 100 5)"))), {
      TAG: /* NumV */0,
      _0: 20
    }, "parse and eval divide!");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("(remainder 10 3)"))), {
      TAG: /* NumV */0,
      _0: 1
    }, "parse and eval remainder 1");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("(remainder 9 8)"))), {
      TAG: /* NumV */0,
      _0: 1
    }, "parse and eval remainder 2");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("(remainder 10 11)"))), {
      TAG: /* NumV */0,
      _0: 10
    }, "parse and eval remainder 3");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("(= 2 3)"))), {
      TAG: /* BoolV */1,
      _0: false
    }, "parse and eval =");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("(< 2 5)"))), {
      TAG: /* BoolV */1,
      _0: true
    }, "parse eval <");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("(> 2 5)"))), {
      TAG: /* BoolV */1,
      _0: false
    }, "parse eval >");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("(<= 2 5)"))), {
      TAG: /* BoolV */1,
      _0: true
    }, "parse eval <= 1");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("(<= 5 5)"))), {
      TAG: /* BoolV */1,
      _0: true
    }, "parse eval <= 2");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("(<= 6 5)"))), {
      TAG: /* BoolV */1,
      _0: false
    }, "parse eval <= 3");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("(>= 2 5)"))), {
      TAG: /* BoolV */1,
      _0: false
    }, "parse eval >= 1");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("(>= 5 5)"))), {
      TAG: /* BoolV */1,
      _0: true
    }, "parse eval >= 2");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("(>= 6 5)"))), {
      TAG: /* BoolV */1,
      _0: true
    }, "parse eval >= 3");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("(equal? (cons 3 (cons 4 empty)) (cons 3 (cons 4 empty)))"))), {
      TAG: /* BoolV */1,
      _0: true
    }, "parse and eval equal? list 1");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("(equal? (cons 3 (cons 4 empty)) (cons 3 (cons 4 (cons 5 empty))))"))), {
      TAG: /* BoolV */1,
      _0: false
    }, "parse and eval equal? list 2");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("(equal? 1 2)"))), {
      TAG: /* BoolV */1,
      _0: false
    }, "parse and eval equal? num 1");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("(equal? 1 1)"))), {
      TAG: /* BoolV */1,
      _0: true
    }, "parse and eval equal? num 2");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("(equal? true true)"))), {
      TAG: /* BoolV */1,
      _0: true
    }, "parse and eval equal? bool 1");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("(equal? true false)"))), {
      TAG: /* BoolV */1,
      _0: false
    }, "parse and eval equal? bool 2");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("(number? 4)"))), {
      TAG: /* BoolV */1,
      _0: true
    }, "parse and eval number? 1");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("(number? empty)"))), {
      TAG: /* BoolV */1,
      _0: false
    }, "parse and eval number? 2");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("(zero? 5)"))), {
      TAG: /* BoolV */1,
      _0: false
    }, "parse and eval zero?");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("(zero? 0)"))), {
      TAG: /* BoolV */1,
      _0: true
    }, "parse and eval zero?");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("(cons 3 empty)"))), {
      TAG: /* ListV */2,
      _0: {
        hd: {
          TAG: /* NumV */0,
          _0: 3
        },
        tl: /* [] */0
      }
    }, "parse and eval cons 1");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("(cons 3 (cons 4 empty))"))), {
      TAG: /* ListV */2,
      _0: {
        hd: {
          TAG: /* NumV */0,
          _0: 3
        },
        tl: {
          hd: {
            TAG: /* NumV */0,
            _0: 4
          },
          tl: /* [] */0
        }
      }
    }, "parse and eval cons 2");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("(rest (cons 3 (cons 4 (cons 5 empty))))"), {
      hd: "(list 4 5)",
      tl: /* [] */0
    }, "rest");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("(empty? (cons 3 empty))"))), {
      TAG: /* BoolV */1,
      _0: false
    }, "empty? parse and eval 1");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("(empty? empty)"))), {
      TAG: /* BoolV */1,
      _0: true
    }, "empty? parse and eval 2");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("(cons? (cons 3 empty))"))), {
      TAG: /* BoolV */1,
      _0: true
    }, "cons? parse and eval 1");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("(cons? empty)"))), {
      TAG: /* BoolV */1,
      _0: false
    }, "cons? parse and eval 2");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("(not true)"))), {
      TAG: /* BoolV */1,
      _0: false
    }, "not parse and eval 1");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("(not (> 2 5))"))), {
      TAG: /* BoolV */1,
      _0: true
    }, "not parse and eval 2");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, parseExpression(Read$RacketteErrorless.Reader.read("(first (cons 3 (cons 4 (cons 5 empty)))))"))), {
      TAG: /* NumV */0,
      _0: 3
    }, "first");

CS17SetupRackette$RacketteErrorless.checkExpect($$process(List.map(parsePiece, {
              hd: {
                TAG: /* ListC */2,
                _0: {
                  hd: {
                    TAG: /* SymbolC */1,
                    _0: "+"
                  },
                  tl: {
                    hd: {
                      TAG: /* NumberC */0,
                      _0: 1
                    },
                    tl: {
                      hd: {
                        TAG: /* NumberC */0,
                        _0: 2
                      },
                      tl: /* [] */0
                    }
                  }
                }
              },
              tl: /* [] */0
            })), {
      hd: {
        TAG: /* NumV */0,
        _0: 3
      },
      tl: /* [] */0
    }, "process");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, {
          hd: [
            /* Name */{
              _0: "x"
            },
            {
              TAG: /* NumV */0,
              _0: 3
            }
          ],
          tl: /* [] */0
        }, {
          TAG: /* NameE */2,
          _0: /* Name */{
            _0: "x"
          }
        }), {
      TAG: /* NumV */0,
      _0: 3
    }, "eval: number");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, {
          TAG: /* NumE */0,
          _0: 4
        }), {
      TAG: /* NumV */0,
      _0: 4
    }, "eval: number");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, {
          TAG: /* BoolE */1,
          _0: true
        }), {
      TAG: /* BoolV */1,
      _0: true
    }, "eval: boolean");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, /* EmptyE */0), {
      TAG: /* ListV */2,
      _0: /* [] */0
    }, "eval: empty list");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, {
          TAG: /* AndE */3,
          _0: {
            TAG: /* BoolE */1,
            _0: true
          },
          _1: {
            TAG: /* BoolE */1,
            _0: false
          }
        }), {
      TAG: /* BoolV */1,
      _0: false
    }, "eval: and");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, {
          TAG: /* OrE */4,
          _0: {
            TAG: /* BoolE */1,
            _0: true
          },
          _1: {
            TAG: /* BoolE */1,
            _0: false
          }
        }), {
      TAG: /* BoolV */1,
      _0: true
    }, "eval: and");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, {
          TAG: /* IfE */5,
          _0: {
            boolExpr: {
              TAG: /* BoolE */1,
              _0: true
            },
            trueExpr: {
              TAG: /* NumE */0,
              _0: 3
            },
            falseExpr: {
              TAG: /* NumE */0,
              _0: 4
            }
          }
        }), {
      TAG: /* NumV */0,
      _0: 3
    }, "eval: if");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, {
          TAG: /* CondE */6,
          _0: {
            hd: {
              conditionExpr: {
                TAG: /* BoolE */1,
                _0: true
              },
              resultExpr: {
                TAG: /* NumE */0,
                _0: 1
              }
            },
            tl: /* [] */0
          }
        }), {
      TAG: /* NumV */0,
      _0: 1
    }, "eval: cond");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, {
          TAG: /* LambdaE */7,
          _0: {
            nameList: {
              hd: /* Name */{
                _0: "x"
              },
              tl: /* [] */0
            },
            lambdaBody: {
              TAG: /* NumE */0,
              _0: 3
            }
          }
        }), {
      TAG: /* ClosureV */4,
      _0: {
        cNameList: {
          hd: /* Name */{
            _0: "x"
          },
          tl: /* [] */0
        },
        cExpr: {
          TAG: /* NumE */0,
          _0: 3
        },
        cEnv: /* [] */0
      }
    }, "eval: lambda");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, {
          TAG: /* LetE */8,
          _0: {
            letPairs: {
              hd: {
                pairName: /* Name */{
                  _0: "x"
                },
                pairExpr: {
                  TAG: /* NumE */0,
                  _0: 1
                }
              },
              tl: /* [] */0
            },
            letBody: {
              TAG: /* BoolE */1,
              _0: false
            }
          }
        }), {
      TAG: /* BoolV */1,
      _0: false
    }, "eval: let");

CS17SetupRackette$RacketteErrorless.checkExpect($$eval(initialTle, /* [] */0, {
          TAG: /* ApplicationE */9,
          _0: {
            hd: {
              TAG: /* NameE */2,
              _0: /* Name */{
                _0: "+"
              }
            },
            tl: {
              hd: {
                TAG: /* NumE */0,
                _0: 1
              },
              tl: {
                hd: {
                  TAG: /* NumE */0,
                  _0: 4
                },
                tl: /* [] */0
              }
            }
          }
        }), {
      TAG: /* NumV */0,
      _0: 5
    }, "eval: application");

CS17SetupRackette$RacketteErrorless.checkExpect($$process({
          hd: {
            TAG: /* Expression */1,
            _0: {
              TAG: /* ApplicationE */9,
              _0: {
                hd: {
                  TAG: /* NameE */2,
                  _0: /* Name */{
                    _0: "+"
                  }
                },
                tl: {
                  hd: {
                    TAG: /* NumE */0,
                    _0: 1
                  },
                  tl: {
                    hd: {
                      TAG: /* NumE */0,
                      _0: 4
                    },
                    tl: /* [] */0
                  }
                }
              }
            }
          },
          tl: /* [] */0
        }), {
      hd: {
        TAG: /* NumV */0,
        _0: 5
      },
      tl: /* [] */0
    }, "process: applicationE");

CS17SetupRackette$RacketteErrorless.checkExpect($$process({
          hd: {
            TAG: /* Expression */1,
            _0: {
              TAG: /* LambdaE */7,
              _0: {
                nameList: {
                  hd: /* Name */{
                    _0: "x"
                  },
                  tl: /* [] */0
                },
                lambdaBody: {
                  TAG: /* NumE */0,
                  _0: 3
                }
              }
            }
          },
          tl: /* [] */0
        }), {
      hd: {
        TAG: /* ClosureV */4,
        _0: {
          cNameList: {
            hd: /* Name */{
              _0: "x"
            },
            tl: /* [] */0
          },
          cExpr: {
            TAG: /* NumE */0,
            _0: 3
          },
          cEnv: /* [] */0
        }
      },
      tl: /* [] */0
    }, "process: lambda");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("3"), {
      hd: "3",
      tl: /* [] */0
    }, "rackette: single number input");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("3 4"), {
      hd: "3",
      tl: {
        hd: "4",
        tl: /* [] */0
      }
    }, "rackette: two number input");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("true"), {
      hd: "true",
      tl: /* [] */0
    }, "rackette: single boo, input");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("(define x 2) x"), {
      hd: "2",
      tl: /* [] */0
    }, "rackette: define num, return num");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("(define y 6) (define x (if (> y 7) 1 2)) x"), {
      hd: "2",
      tl: /* [] */0
    }, "rackette: defining two values, using one value to define the other");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("(+ 3 5)"), {
      hd: "8",
      tl: /* [] */0
    }, "rackette: adding");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("(define x 1) (+ x 2)"), {
      hd: "3",
      tl: /* [] */0
    }, "rackette: define name, add to name");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("(> 3 5)"), {
      hd: "false",
      tl: /* [] */0
    }, "rackette: num comparison");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("(define x 3) (define y 4) (> y x)"), {
      hd: "true",
      tl: /* [] */0
    }, "rackette: define variables and compare");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("(and (> 5 4) (< 4 8))"), {
      hd: "true",
      tl: /* [] */0
    }, "rackette on and");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("(and (> 3 4) (< 4 8))"), {
      hd: "false",
      tl: /* [] */0
    }, "rackette: and -> short circuit to false");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("(and (> 6 4) (< 9 8))"), {
      hd: "false",
      tl: /* [] */0
    }, "rackette: and, false on second expression");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("(or (> 5 4) (< 4 8))"), {
      hd: "true",
      tl: /* [] */0
    }, "rackette: or -> short circuit to true");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("(or (> 1 4) (< 4 8))"), {
      hd: "true",
      tl: /* [] */0
    }, "rackette:  or -> second expr true, first false");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("(define a 8) (if (>= a 8) 8 1)"), {
      hd: "8",
      tl: /* [] */0
    }, "rackette: if");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("(define a 1) (if (= a 1) 99 100)"), {
      hd: "99",
      tl: /* [] */0
    }, "rackette: a eval to true");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("(define a false)(if a 99 100)"), {
      hd: "100",
      tl: /* [] */0
    }, "rackette: a eval to false");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("(define a 1) (+ a 2)"), {
      hd: "3",
      tl: /* [] */0
    }, "simple rackette define");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("(define a true) (not a)"), {
      hd: "false",
      tl: /* [] */0
    }, "simple rackette define with bool");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("(define a 1) (if (= a 1) 4 1)"), {
      hd: "4",
      tl: /* [] */0
    }, "simple rackette define with if");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("(define a empty) (if (empty? a) 4 1)"), {
      hd: "4",
      tl: /* [] */0
    }, "simple rackette define with empty, if");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("(define a false) (if a 4 1)"), {
      hd: "1",
      tl: /* [] */0
    }, "simple rackette define with if");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("(define u (cons 8 (cons 1 empty)))(if (> (first u) 5) (first u) (rest u))"), {
      hd: "8",
      tl: /* [] */0
    }, "rackette: if and first on list");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("(define u (cons 3 (cons 1 empty)))(if (> (first u) 5) (first u) (rest u))"), {
      hd: "(list 1)",
      tl: /* [] */0
    }, "rackette: if and rest on list");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("(define a 1) (cond ((= a 1) 4))"), {
      hd: "4",
      tl: /* [] */0
    }, "simple rackette define with cond");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("(define a (cons 3 (cons 99 (cons 0 empty))))(cond ((> 1 (first a))(first a)) ((= 1 (first a)) 1) ((< 1 (first a)) (let ((x 4))(cons x a))))"), {
      hd: "(list 4 3 99 0)",
      tl: /* [] */0
    }, "rackette: cond and let");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("(define a (cons 3 (cons 99 (cons 0 empty)))) (cond ((>= 1 (first a))(first a)) ((< 1 (first a)) ((lambda (x) (* x 3)) (first a))))"), {
      hd: "9",
      tl: /* [] */0
    }, "rackette: cond and lambda");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("((lambda (x y z) (cons x (cons y (cons z empty)))) 9 0 8)"), {
      hd: "(list 9 0 8)",
      tl: /* [] */0
    }, "rackette: use lambda to form a list");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("((lambda (x y z) (+ x (- z y))) 9 0 8)"), {
      hd: "17",
      tl: /* [] */0
    }, "rackette: use lambda to add");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("(define f (lambda (x) (+ x 2)))(f 3)"), {
      hd: "5",
      tl: /* [] */0
    }, "rackette: checking basic lambda application");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("((lambda (x) (* x x)) 4)"), {
      hd: "16",
      tl: /* [] */0
    }, "rackette: basic application with lambda");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("(lambda (x) (* 8 x))"), {
      hd: "#<procedure>",
      tl: /* [] */0
    }, "rackette: use lambda to create procedure");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("(let (( x 8 ) (y 3)) (- x y))"), {
      hd: "5",
      tl: /* [] */0
    }, "rackette: let expression");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("(let ((x 2) (y 6)) (let (( x y )) (/ y x)))"), {
      hd: "1",
      tl: /* [] */0
    }, "rackette: nested lets");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("(let (( x 8 ) (y 3)) (let ((x y)) ((lambda (x y) (+ x y)) x y)))"), {
      hd: "6",
      tl: /* [] */0
    }, "rackette: nested lets and lambda");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("(define x 11) (let ((x 4))(cond ((> 10 x) x) ((<= 10 x) 11)))"), {
      hd: "4",
      tl: /* [] */0
    }, "rackette: nested let, cond, and local vs. tle");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("((lambda (x y) ((lambda (y) (+ x y)) x)) (let ((x 0) (y 18))(let ((f (lambda (a b) (+ x b ))) (x 17)) (f y x))) 18)"), {
      hd: "34",
      tl: /* [] */0
    }, "ahh!");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("((lambda (x y) ((lambda (y) (+ x y)) x)) 17 18)(let ((x 0) (y 18))(let ((f (lambda (a b) (+ x b ))) (x 17)) (f y x)))(define y 17)(let ((y 3)) ( + y 7) )"), {
      hd: "34",
      tl: {
        hd: "17",
        tl: {
          hd: "10",
          tl: /* [] */0
        }
      }
    }, "programs in succession w/ local env manipulation");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("(define x (cons 4 (cons 5 (cons 6 empty))))(cond((> 9 (first x))(cons 9 x)))x(let ((x 3)) (cons x (cons x empty)))x"), {
      hd: "(list 9 4 5 6)",
      tl: {
        hd: "(list 4 5 6)",
        tl: {
          hd: "(list 3 3)",
          tl: {
            hd: "(list 4 5 6)",
            tl: /* [] */0
          }
        }
      }
    }, "changing local and tle, multi-procedure");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("(define a empty)(let ((a (/ 99 (+ 10 1))))(cons a empty))(empty? a)(equal? a empty)"), {
      hd: "(list 9)",
      tl: {
        hd: "true",
        tl: {
          hd: "true",
          tl: /* [] */0
        }
      }
    }, "multi procedure output, lists, let");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("(define a 9397983923)(define b 33333)(let ((b 9397983923))(and (equal? b a) (not false)))(equal? b a)"), {
      hd: "true",
      tl: {
        hd: "false",
        tl: /* [] */0
      }
    }, "multi-output, with equal?, not, let, and local env. manipulation");

CS17SetupRackette$RacketteErrorless.checkExpect(addDefinition(/* [] */0, [
          /* Name */{
            _0: "x"
          },
          {
            TAG: /* NumE */0,
            _0: 3
          }
        ]), {
      hd: [
        /* Name */{
          _0: "x"
        },
        {
          TAG: /* NumV */0,
          _0: 3
        }
      ],
      tl: /* [] */0
    }, "checking addDefinition");

CS17SetupRackette$RacketteErrorless.checkExpect(addDefinition({
          hd: [
            /* Name */{
              _0: "y"
            },
            {
              TAG: /* BoolV */1,
              _0: true
            }
          ],
          tl: /* [] */0
        }, [
          /* Name */{
            _0: "x"
          },
          {
            TAG: /* NumE */0,
            _0: 3
          }
        ]), {
      hd: [
        /* Name */{
          _0: "x"
        },
        {
          TAG: /* NumV */0,
          _0: 3
        }
      ],
      tl: {
        hd: [
          /* Name */{
            _0: "y"
          },
          {
            TAG: /* BoolV */1,
            _0: true
          }
        ],
        tl: /* [] */0
      }
    }, "checking addDefinition -> already have definition in env");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("((lambda (x y) ((lambda (y) (+ x y)) x)) 17 18)"), {
      hd: "34",
      tl: /* [] */0
    }, "eval by hand #1");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("(let ((x 0) (y 18)) (let ((f (lambda (a b) (+ x b ))) (x 17)) (f y x)))"), {
      hd: "17",
      tl: /* [] */0
    }, "eval by hand #2");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("(+ 3 5)"), {
      hd: "8",
      tl: /* [] */0
    }, "eval by hand #3");

CS17SetupRackette$RacketteErrorless.checkExpect(rackette("(define y 17) (let ((y 3)) ( + y 7) )"), {
      hd: "10",
      tl: /* [] */0
    }, "eval by hand #4");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(+)");
      }), "Must have two numbers to add");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(+ 3 true)");
      }), "Must have two numbers to add");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(-)");
      }), "Must have two numbers to subtract");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(- 3 true)");
      }), "Must have two numbers to subtract");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(*)");
      }), "Must have two numbers to multiply");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(* 11 false)");
      }), "Must have two numbers to multiply");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(/)");
      }), "Must have two numbers to divide");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(/ 10 false)");
      }), "Must have two numbers to divide");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(remainder)");
      }), "Must have two numbers to find remainder");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(remainder 3 true)");
      }), "Must have two numbers to find remainder");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(<)");
      }), "must have two numbers to use <");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(< false true)");
      }), "must have two numbers to use <");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(>)");
      }), "must have two numbers to use >");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(> false true)");
      }), "must have two numbers to use >");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(>=)");
      }), "must have two numbers to use >=");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(>= 0 true)");
      }), "must have two numbers to use >=");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(<=)");
      }), "must have two numbers to use <=");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(<= false 4)");
      }), "must have two numbers to use <=");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(=)");
      }), "must have two numbers to use =");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(= false true)");
      }), "must have two numbers to use =");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(zero? empty)");
      }), "can only use zero? on ints");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(first empty)");
      }), "cannot call first on an empty list");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(first 7)");
      }), "cannot call first on a non-list");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(rest empty)");
      }), "cannot call rest on an empty list");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(rest 7)");
      }), "cannot call rest on a non-list");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(cons 5)");
      }), "cons expression must contain item, then ListV");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(empty? 5)");
      }), "cannot call empty? on a non-list");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(cons? 5)");
      }), "cannot call cons? on a non-list");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(not 5)");
      }), "not can only be called on boolean values");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(equal? 5)");
      }), "equal? can only compare two NumVs, BoolVs, or ListVs");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(and true)");
      }), "and must be followed by two boolean expressions");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(or true 5 8)");
      }), "or must be followed by two boolean expressions");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(if true)");
      }), "if statements must have a predicate followed by two expressions");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(if true 5 false 4)");
      }), "if statements must have a predicate followed by two expressions");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(cond)");
      }), "cond must be followed by at least one condition/result pair.");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(lambda)");
      }), "lambda expressions must contain a list of names followed by an list of expressions");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(lambda 3 (+ 1 1))");
      }), "lambda expressions must contain a list of names followed by an list of expressions");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(lambda empty (+ 2 1))");
      }), "lambda expressions must contain a list of names followed by an list of expressions");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(let 3)");
      }), "let expressions must contain a list of one or more let pairs and a list of one or more expressions");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(let (empty) (+ x 1))");
      }), "improper let expression syntax");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(let (x) (+ x 1))");
      }), "improper let expression syntax");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(define 8 7)");
      }), "definition has invalid format");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(define a)");
      }), "definition must be followed by an expression");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(+ n 1)");
      }), "name not yet bound to value");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(and 1 false)");
      }), "the first clause of an and must evaluate to a boolean");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(and true 1)");
      }), "the second clause of an and must evaluate to a boolean");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(or 1 false)");
      }), "the first clause of or must evaluate to a boolean");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(or false 1)");
      }), "the second clause of or must evaluate to a boolean");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(if 1 3 4)");
      }), "first condition of if expression must evaluate to boolean");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("(cond (1 3) (3 4))");
      }), "condition expressions must evaluate to true/false values");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("((lambda (x) (+ x 1)) 4 1)");
      }), "must have same number of formals and actuals");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return rackette("((lambda (x) (+ x 1)))");
      }), "must have same number of formals and actuals");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return $$eval(initialTle, /* [] */0, parseExpression({
                        TAG: /* ListC */2,
                        _0: {
                          hd: {
                            TAG: /* NumberC */0,
                            _0: 3
                          },
                          tl: {
                            hd: {
                              TAG: /* NumberC */0,
                              _0: 4
                            },
                            tl: {
                              hd: {
                                TAG: /* NumberC */0,
                                _0: 5
                              },
                              tl: /* [] */0
                            }
                          }
                        }
                      }));
      }), "Application expression must start with a procedure");

CS17SetupRackette$RacketteErrorless.checkError((function (param) {
        return addDefinition({
                    hd: [
                      /* Name */{
                        _0: "n"
                      },
                      {
                        TAG: /* NumV */0,
                        _0: 3
                      }
                    ],
                    tl: /* [] */0
                  }, [
                    /* Name */{
                      _0: "n"
                    },
                    {
                      TAG: /* NumE */0,
                      _0: 7
                    }
                  ]);
      }), "cannot redefine names; name already used");

exports.plus = plus;
exports.minus = minus;
exports.times = times;
exports.divide = divide;
exports.remainder = remainder;
exports.lessThan = lessThan;
exports.greaterThan = greaterThan;
exports.lessThanEqualTo = lessThanEqualTo;
exports.greaterThanEqualTo = greaterThanEqualTo;
exports.equal = equal;
exports.isItANumber = isItANumber;
exports.isItZero = isItZero;
exports.first = first;
exports.rest = rest;
exports.cons = cons;
exports.istItEmpty = istItEmpty;
exports.isItCons = isItCons;
exports.myNot = myNot;
exports.equalQuery = equalQuery;
exports.initialTle = initialTle;
exports.parseExpression = parseExpression;
exports.parseDefinition = parseDefinition;
exports.parsePiece = parsePiece;
exports.parse = parse;
exports.lookup = lookup;
exports.lookupVal = lookupVal;
exports.lambdaEHelper = lambdaEHelper;
exports.letEDuplicate = letEDuplicate;
exports.$$eval = $$eval;
exports.addDefinition = addDefinition;
exports.stringOfValue = stringOfValue;
exports.$$process = $$process;
exports.rackette = rackette;
/*  Not a pure module */
